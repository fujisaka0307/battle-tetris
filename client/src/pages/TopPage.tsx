import { useState, useCallback, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { ROOM_ID_LENGTH } from '@battle-tetris/shared';
import type { WaitingRoomInfo, RankingEntry, MatchHistoryEntry } from '@battle-tetris/shared';
import { signalRClient } from '../network/SignalRClient';
import { usePlayerStore } from '../stores/usePlayerStore';
import { useGameStore } from '../stores/useGameStore';
import { useAuth } from '../auth/useAuth';

export default function TopPage() {
  const navigate = useNavigate();
  const { setEnterpriseId: storeEnterpriseId, setRoomId } = usePlayerStore();
  const { enterpriseId, logout, getToken } = useAuth();

  const [roomId, setRoomId_] = useState('');
  const [error, setError] = useState('');
  const [isConnecting, setIsConnecting] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [waitingRooms, setWaitingRooms] = useState<WaitingRoomInfo[]>([]);
  const [rankings, setRankings] = useState<RankingEntry[]>([]);
  const [matchHistory, setMatchHistory] = useState<MatchHistoryEntry[]>([]);
  const [aiLevel, setAiLevel] = useState(5);
  const subscribedRef = useRef(false);
  const connectingPromiseRef = useRef<Promise<boolean> | null>(null);

  const roomIdValid = /^[A-Za-z0-9]{6}$/.test(roomId);

  const ensureConnected = useCallback(async () => {
    if (signalRClient.state === 'connected') return true;
    if (connectingPromiseRef.current) return connectingPromiseRef.current;
    setIsConnecting(true);
    const promise = (async () => {
      try {
        const url = import.meta.env.VITE_SIGNALR_URL || '/hub';
        const token = await getToken();
        if (token) {
          await signalRClient.connect(url, async () => token);
        } else {
          await signalRClient.connect(url);
        }
        return true;
      } catch {
        setError('ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸ');
        return false;
      } finally {
        setIsConnecting(false);
        connectingPromiseRef.current = null;
      }
    })();
    connectingPromiseRef.current = promise;
    return promise;
  }, [getToken]);

  // Enterprise ID ã‚’ã‚¹ãƒˆã‚¢ã«ä¿å­˜
  useEffect(() => {
    if (enterpriseId) {
      storeEnterpriseId(enterpriseId);
    }
  }, [enterpriseId, storeEnterpriseId]);

  // æ—©æœŸæ¥ç¶šã¨ãƒ«ãƒ¼ãƒ ãƒªã‚¹ãƒˆãƒ»ãƒªãƒ¼ãƒ€ãƒ¼ãƒœãƒ¼ãƒ‰è³¼èª­
  useEffect(() => {
    let cancelled = false;
    const connectAndSubscribe = async () => {
      const connected = await ensureConnected();
      if (!cancelled && connected && signalRClient.state === 'connected') {
        signalRClient.setHandlers({
          onWaitingRoomListUpdated: (payload) => {
            if (!cancelled) setWaitingRooms(payload.rooms);
          },
          onLeaderboardUpdated: (payload) => {
            if (!cancelled) setRankings(payload.rankings);
          },
          onMatchHistoryUpdated: (payload) => {
            if (!cancelled) setMatchHistory(payload.matches);
          },
        });
        signalRClient.sendSubscribeRoomList();
        signalRClient.sendSubscribeLeaderboard();
        subscribedRef.current = true;
        setIsReady(true);
      }
    };
    connectAndSubscribe();
    return () => {
      cancelled = true;
      if (subscribedRef.current) {
        signalRClient.sendUnsubscribeRoomList();
        signalRClient.sendUnsubscribeLeaderboard();
        subscribedRef.current = false;
      }
    };
  }, [ensureConnected]);

  const subscribeIfNeeded = useCallback(() => {
    if (!subscribedRef.current && signalRClient.state === 'connected') {
      signalRClient.sendSubscribeRoomList();
      subscribedRef.current = true;
    }
  }, []);

  const handleCreateRoom = useCallback(async () => {
    setError('');

    if (!(await ensureConnected())) return;

    signalRClient.setHandlers({
      onRoomCreated: (payload) => {
        setRoomId(payload.roomId);
        navigate(`/lobby/${payload.roomId}`);
      },
      onWaitingRoomListUpdated: (payload) => setWaitingRooms(payload.rooms),
      onLeaderboardUpdated: (payload) => setRankings(payload.rankings),
      onMatchHistoryUpdated: (payload) => setMatchHistory(payload.matches),
      onError: (payload) => setError(payload.message),
    });

    subscribeIfNeeded();
    signalRClient.sendCreateRoom();
  }, [ensureConnected, setRoomId, navigate, subscribeIfNeeded]);

  const handleJoinRoom = useCallback(async () => {
    if (!roomIdValid) return;
    setError('');

    if (!(await ensureConnected())) return;

    signalRClient.setHandlers({
      onOpponentJoined: (payload) => {
        setRoomId(roomId.toUpperCase());
        usePlayerStore.getState().setOpponentEnterpriseId(payload.enterpriseId);
        navigate(`/lobby/${roomId.toUpperCase()}`);
      },
      onWaitingRoomListUpdated: (payload) => setWaitingRooms(payload.rooms),
      onLeaderboardUpdated: (payload) => setRankings(payload.rankings),
      onMatchHistoryUpdated: (payload) => setMatchHistory(payload.matches),
      onError: (payload) => setError(payload.message),
    });

    subscribeIfNeeded();
    signalRClient.sendJoinRoom(roomId.toUpperCase());
  }, [roomId, roomIdValid, ensureConnected, setRoomId, navigate, subscribeIfNeeded]);

  const handleJoinFromList = useCallback(async (targetRoomId: string) => {
    setError('');

    if (!(await ensureConnected())) return;

    signalRClient.setHandlers({
      onOpponentJoined: (payload) => {
        setRoomId(targetRoomId);
        usePlayerStore.getState().setOpponentEnterpriseId(payload.enterpriseId);
        navigate(`/lobby/${targetRoomId}`);
      },
      onWaitingRoomListUpdated: (payload) => setWaitingRooms(payload.rooms),
      onLeaderboardUpdated: (payload) => setRankings(payload.rankings),
      onMatchHistoryUpdated: (payload) => setMatchHistory(payload.matches),
      onError: (payload) => setError(payload.message),
    });

    subscribeIfNeeded();
    signalRClient.sendJoinRoom(targetRoomId);
  }, [ensureConnected, setRoomId, navigate, subscribeIfNeeded]);

  const handleCreateAiRoom = useCallback(async () => {
    setError('');

    if (!(await ensureConnected())) return;

    signalRClient.setHandlers({
      onRoomCreated: (payload) => {
        setRoomId(payload.roomId);
        navigate(`/lobby/${payload.roomId}`);
      },
      onOpponentJoined: (payload) => {
        usePlayerStore.getState().setOpponentEnterpriseId(payload.enterpriseId);
      },
      onBothReady: (payload) => {
        useGameStore.getState().setSeed(payload.seed);
        useGameStore.getState().setPendingCountdown(payload.countdown);
      },
      onWaitingRoomListUpdated: (payload) => setWaitingRooms(payload.rooms),
      onLeaderboardUpdated: (payload) => setRankings(payload.rankings),
      onMatchHistoryUpdated: (payload) => setMatchHistory(payload.matches),
      onError: (payload) => setError(payload.message),
    });

    subscribeIfNeeded();
    signalRClient.sendCreateAiRoom(aiLevel);
  }, [aiLevel, ensureConnected, setRoomId, navigate, subscribeIfNeeded]);

  return (
    <div className="top-page">
      {/* ---- å·¦ä¸Š è¨­å®šãƒœã‚¿ãƒ³ (CI/CD Dashboard) ---- */}
      <button
        onClick={() => navigate('/dashboard')}
        className="top-settings-btn"
        data-testid="dashboard-link"
        title="CI/CD Dashboard"
        aria-label="CI/CD Dashboard"
      >
        âš™ï¸
      </button>

      {/* ---- ãƒ˜ãƒƒãƒ€ãƒ¼ ---- */}
      <div className="top-header">
        <span className="top-logo-icon" aria-hidden="true">ğŸ®</span>
        <h1 className="top-title">Battle Tetris</h1>
        <p className="top-subtitle">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ ãŸã„ã›ã‚“</p>
      </div>

      {/* ---- Enterprise ID ãƒãƒƒã‚¸ + ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ ---- */}
      <div className="top-section" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
        <span className="top-enterprise-badge" data-testid="enterprise-id">
          {enterpriseId}
        </span>
        <button
          onClick={logout}
          className="top-logout-btn"
          data-testid="logout-btn"
        >
          ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
        </button>
      </div>

      {/* ---- ãƒ¢ãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ ---- */}
      <div className="top-cards">
        {/* ã‚«ãƒ¼ãƒ‰1 â€” ãƒ«ãƒ¼ãƒ ä½œæˆ */}
        <div className="mode-card mode-card--cyan">
          <span className="mode-card-icon" aria-hidden="true">ğŸ </span>
          <div className="mode-card-body">
            <p className="mode-card-title">ã¸ã‚„ã‚’ ã¤ãã‚‹</p>
            <p className="mode-card-desc">ã‚ãŸã‚‰ã—ã„ ã¸ã‚„ã‚’ ã¤ãã£ã¦ ã¨ã‚‚ã ã¡ã‚’ ã¾ã¨ã†</p>
          </div>
          <button
            onClick={handleCreateRoom}
            disabled={!isReady || isConnecting}
            className="mode-btn mode-btn--cyan"
            data-testid="create-room-btn"
          >
            ã¤ãã‚‹
          </button>
        </div>

        {/* ã‚«ãƒ¼ãƒ‰2 â€” ãƒ«ãƒ¼ãƒ å‚åŠ  */}
        <div className="mode-card mode-card--green">
          <span className="mode-card-icon" aria-hidden="true">ğŸ”‘</span>
          <div className="mode-card-body">
            <p className="mode-card-title">ã¸ã‚„ã« ã¯ã„ã‚‹</p>
            <p className="mode-card-desc">ã¨ã‚‚ã ã¡ã® ã¸ã‚„IDã‚’ ã„ã‚Œã¦ ã•ã‚“ã‹ã—ã‚ˆã†</p>
            <div className="mode-card-join-row">
              <input
                type="text"
                value={roomId}
                onChange={(e) => setRoomId_(e.target.value.toUpperCase())}
                maxLength={ROOM_ID_LENGTH}
                placeholder="ã¸ã‚„ID (6ã‚‚ã˜)"
                className="top-room-input"
                data-testid="room-id-input"
                aria-label="ã¸ã‚„ID"
              />
              <button
                onClick={handleJoinRoom}
                disabled={!roomIdValid || !isReady || isConnecting}
                className="mode-btn mode-btn--green mode-btn--small"
                data-testid="join-room-btn"
              >
                ã¯ã„ã‚‹
              </button>
            </div>
          </div>
        </div>

        {/* ã‚«ãƒ¼ãƒ‰3 â€” AIå¯¾æˆ¦ */}
        <div className="mode-card mode-card--purple">
          <span className="mode-card-icon" aria-hidden="true">ğŸ¤–</span>
          <div className="mode-card-body">
            <p className="mode-card-title">AI ã¨ ãŸã„ã›ã‚“</p>
            <p className="mode-card-desc">ã¤ã‚ˆã•ã‚’ ãˆã‚‰ã‚“ã§ AIã¨ ã—ã‚‡ã†ã¶ï¼</p>
            <div className="mode-card-join-row">
              <select
                value={aiLevel}
                onChange={(e) => setAiLevel(Number(e.target.value))}
                className="top-ai-select"
                data-testid="ai-level-select"
                aria-label="AIãƒ¬ãƒ™ãƒ«"
              >
                {Array.from({ length: 10 }, (_, i) => i + 1).map((lv) => (
                  <option key={lv} value={lv}>
                    Lv.{lv}
                  </option>
                ))}
              </select>
              <button
                onClick={handleCreateAiRoom}
                disabled={!isReady || isConnecting}
                className="mode-btn mode-btn--purple mode-btn--small"
                data-testid="ai-battle-btn"
              >
                ãŸã„ã›ã‚“
              </button>
            </div>
          </div>
        </div>

      </div>

      {/* ---- å¾…æ©Ÿä¸­ãƒ«ãƒ¼ãƒ ãƒªã‚¹ãƒˆ ---- */}
      {waitingRooms.length > 0 && (
        <div className="top-section top-waiting" data-testid="waiting-room-list">
          <h2 className="top-label">ã¾ã£ã¦ã„ã‚‹ ã¸ã‚„</h2>
          <div className="top-waiting-list">
            {waitingRooms.map((room) => (
              <div
                key={room.roomId}
                className="waiting-card"
                data-testid="waiting-room-item"
              >
                <div className="waiting-card-info">
                  <span className="waiting-card-id" data-testid="waiting-room-id">
                    {room.roomId}
                  </span>
                  <span className="waiting-card-creator" data-testid="waiting-room-creator">
                    {room.creatorEnterpriseId}
                  </span>
                </div>
                <button
                  onClick={() => handleJoinFromList(room.roomId)}
                  disabled={!isReady || isConnecting}
                  className="mode-btn mode-btn--green mode-btn--small"
                  data-testid="waiting-room-join-btn"
                >
                  ã¯ã„ã‚‹
                </button>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* ---- ãƒ©ãƒ³ã‚­ãƒ³ã‚° & å¯¾æˆ¦å±¥æ­´ ---- */}
      <div className="top-stats-row">
        {/* ãƒ©ãƒ³ã‚­ãƒ³ã‚° */}
        <div className="top-section top-ranking" data-testid="ranking-list">
          <h2 className="top-label">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
          {rankings.length > 0 ? (
            <table className="ranking-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</th>
                  <th>W</th>
                  <th>L</th>
                  <th>ã—ã‚‡ã†ã‚Šã¤</th>
                </tr>
              </thead>
              <tbody>
                {rankings.map((r) => (
                  <tr key={r.enterpriseId} className="ranking-row" data-testid="ranking-item">
                    <td className="ranking-rank">{r.rank}</td>
                    <td className="ranking-player">{r.enterpriseId}</td>
                    <td className="ranking-wins">{r.wins}</td>
                    <td className="ranking-losses">{r.losses}</td>
                    <td className="ranking-rate">{r.winRate}%</td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p className="top-empty" data-testid="ranking-empty">ã¾ã  ãã‚ããŒ ã‚ã‚Šã¾ã›ã‚“</p>
          )}
        </div>

        {/* å¯¾æˆ¦å±¥æ­´ */}
        <div className="top-section top-history" data-testid="match-history">
          <h2 className="top-label">ãŸã„ã›ã‚“ ã‚Šã‚Œã</h2>
          {matchHistory.length > 0 ? (
            <div className="history-list">
              {matchHistory.map((m) => (
                <div key={m.id} className="history-card" data-testid="history-item">
                  <div className="history-players">
                    <span className="history-winner">{m.winnerId}</span>
                    <span className="history-vs">VS</span>
                    <span className="history-loser">{m.loserId}</span>
                  </div>
                  <div className="history-details">
                    <span>{m.winnerScore} - {m.loserScore}</span>
                    {m.isAiMatch && <span className="history-ai-badge">AI</span>}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="top-empty" data-testid="history-empty">ã¾ã  ãã‚ããŒ ã‚ã‚Šã¾ã›ã‚“</p>
          )}
        </div>
      </div>

      {/* ---- ã‚¨ãƒ©ãƒ¼ / æ¥ç¶šä¸­ ---- */}
      {error && (
        <p className="top-error" data-testid="error-message">
          {error}
        </p>
      )}

      {isConnecting && (
        <div className="top-connecting">
          <span className="top-connecting-dot" />
          <span>ã›ã¤ããã¡ã‚…ã†...</span>
        </div>
      )}
    </div>
  );
}
